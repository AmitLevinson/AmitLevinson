---
title: Recursive CTE to Identify Money Transfers
author: Amit Grinson
date: '2023-08-29'
layout: single-sidebar
slug: recursive-cte
categories: [SQL]
tags: [SQL, Recursion]
subtitle: 'Learning recursive CTEs by following payment activity'
summary: 'Though not commonly used, recursive CTEs can be a great tool to work with hierarchal data. In this post we learn to use them to identify where money was moved to by following the transfer activity'
featured: yes
projects: []
mermaid: true
format: hugo-md
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, eval = TRUE)
```


```{r, echo = FALSE}
knit_print.data.frame = function(x, ...) {
  res = paste(c("", "", knitr::kable(x)), collapse = "\n")
  knitr::asis_output(res)
}

registerS3method(
  "knit_print", "data.frame", knit_print.data.frame,
  envir = asNamespace("knitr")
)
```


> "Roses are red  
  Violets are blue,  
  Write a Recursion
  and the DBA will find you"
  
<br>

Recursive CTEs is one of those things I occasionally encountered but never really understood. When I did sought out information to learn mroe about it, it was usually one of those 'identify who's who's boss'. While this may work for some, to me it seem like a far fetched example completely unrelated to my work.

The first time I used it was to calculate the weekdays for a given day from the start of the year, an example from Anthony Molinaro's "SQL Cookbook". It worked great and finally clicked how I can further use this. When I wanted to share it with my team, I thought of a more relateable example of using it to identify where the funds went (more on that below).

Hopefully either example (the generic and mine) will help you grasp it a little more. It's probably not a hammer to be used frequently, but not bad to have it in your toolbox.

<details>
<summary>Setting up a SQL connection</summary>

I write my blog using the [Rstudio IDE](https://posit.co/) and although this post will focus on SQL, we need  to set up a local SQL connection. We're basically connecting to our local RDBMS, here MSSQL, and to a database I setup earlier.

```{r}
library(odbc)
library(DBI)

sqlconn <- dbConnect(odbc(),
                      Driver = "SQL Server",
                      Server = "localhost\\SQLEXPRESS",
                      Database = "recursion")
```

We also need to load the data for this post to the database. It's only needed once and we can do it in R as follows:

```{r, eval = FALSE}
dat <- read.csv('content/blog/recursive-cte/payments.csv', colClasses = c('numeric', 'character', 'character', 'numeric', 'Date'))

dbWriteTable(conn = sqlconn, 'payments', dat, field.types = c(payment_id = 'INT', payer = 'VARCHAR(10)', 
                                                  receiver = 'VARCHAR(10)', amount = 'INT',
                                                  payment_date = 'DATE'), overwrite = TRUE)
```


**Aside:** Moving forward we'll be using SQL code only. instead of having to write SQL code through some R function we can use the SQL engine directly in the code chunks. Just add the connection you created to the chunk header as such:

```{r results='asis'}
cat("```{sql connection='sqlconn', echo = TRUE}```", '```', sep = '\n')
```

</details>

## Basic Example

Well, before we talk about a recursive CTE let's briefly discuss a recursion in general. A recursion, as Wikipedia notes, is defined in terms of itself or of its type. In other words, I like to think of it as something that calls itself.

In SQL (here MSSQL), **a recursion comes into play with a Common table expression (aka CTE), where we call the table we're currently evaluating.** 

For example, to count until 10 (1000, ...) in SQL, we can run the following:


```{sql connection='sqlconn', echo = TRUE}
WITH RecursiveCTE as (
  SELECT 1 as N
  UNION ALL
  SELECT N + 1 as N
  FROM RecursiveCTE
  WHERE N < 10
)

SELECT * FROM RecursiveCTE
```

### Block Breakdown

Let's break that query up and understand how it works:

1. The first part `SELECT 1 as N` is basically the Anchor. You must have one as it sets the ground for the recursion to follow, building up on that.

2. The second piece is a `UNION ALL` which is required in a recursive CTE. It basically makes sure all rows are returned, 'stacking them on top of one another.

3. The third part is, in a sense, the recursion itself. When calling the CTE were creating we're bring the value we selected previously before the union — `1`. We select the value and add a 1 to it, returning for the second iteration the values 1, 2 (unioned). This repeats for the third, fourth... until we reach a threshold we set, `WHERE N < 10`, and our query breaks out. 

A threshold is important to break out, especially if the complexity of the problem *might* increase substantially in each iteration as we'll see shortly. Besides the exit option in the `WHERE` clause, the default recursion will go to a max of 100 iterations. 

-----

Unlimited Iterations and Errors

Running the above query for more iterations on the default max (of 100) will throw an error:

XXXXXXX Error XXXXXXX

If you want your recursion to go more than 100 iterations, just set the maxrecursion option to what you need, for example:

```{.sql}
WITH RecursiveCTE AS (
 ...
)

SELECT * FROM RecursiveCTE
OPTION(MAXRECURSION 200)
```


```{sql connection='sqlconn', echo = TRUE, error = TRUE}
WITH RecursiveCTE as (
  SELECT 1 as N
  UNION ALL
  SELECT N + 1 as N
  FROM RecursiveCTE
  WHERE N < 1000
)

SELECT * FROM RecursiveCTE
```

I'd think carefully before running an unlimited recursion. But if you do, set the `MAXRECURSION` to 0 and hope your breaking option in the WHERE caluse will help.


----------

## Following the Money

Let's move on to a more practical example, or at least more practical for me. Payoneer is a payments platform and as a result we analyze large quantities of payments. A scenario that might occur is wanting to track the flow of money sent from one user to another, from that user to another and so on down the chain. **Given 


User A receives the funds from somewhere and transfers it down the chain. Eventually, it ends up with user D and F (for simplicity we'll use a one-directional relationship). Starting with A, I'd like to identify the final users of the chain. 

**Why does a recursion help here?** Well, usually actions like these - a payment of sort - are recorded in a tabular normalized way — Each row contains the information about one payment. That makes it a little more complex and instead of multiple endless joins, let's solve it with a recursive CTE:

<div class="mermaid">
title[<u>My Title</u>]
graph LR;
  title Flow of funds between users
  A(User A)--1-->B(User B);
  B(User B)--2-->C(User C);
  C(User C)--3-->D(User D);
  C(User C)--3-->E(User E);
  E(User E)--4-->F(User F);
  D(User D)--4-->G(User G);
  G(User G)--5-->H(User H);
  F(User F)--5-->H(User H);
caption Given a user, we'd like to know where the funds ended up
</div>
<script async src="https://unpkg.com/mermaid@8.2.3/dist/mermaid.min.js"></script>

Identifying the chain of transactions shows us **where the funds ended up as well as other actors along the way, returning a network of senders (payers) and receivers**.
test

dasdasdtwe

test

- our example




```{r echo = FALSE}
dbDisconnect(sqlconn)
```

