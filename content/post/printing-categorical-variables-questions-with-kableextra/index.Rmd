---
title: Nicely Printing Categorical Variables with KableExtra
author: Amit Levinson
date: '2020-05-01'
slug: printing-table
categories: []
tags: []
subtitle: ''
summary: "A tribute for for the KableExtra's ability to aestheticaly print descriptives for categorical variables"
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
draft: true
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.align = 'center', out.width = "80%")
```

<style>
p.caption {
  font-size: 0.8em;
}
</style>

This post is somewhat of a ~love post~ tribute to both the iteration abilities in R combined with the [`KableExtra`](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html) package. I set myself several goals for my thesis, one of them is doing my survey analysis in something other than SPSS. I wanted to finish my Masters' with some broader knowledge of statistical programs and dive a little more into coding. I started learning R nearly a year ago so that when the time comes - When my pilot and survey results come in - I can analyze it all in R. 

The time came and I started to analyze the data in R. However, the problem was, That I wasn't going to do an OK job. After discovering much of R's abilities, I wasn't going to let myself copy+paste. So I wrote a few functions, manipulated some of the work and then it was time to get out the big guns; well big guns at least for me.

### The Problem

In my pilot survey I had several questions (~20) that were categorical, ordinal and were simple constructs that didn't require a more thorough analysis such as reliability of the scale. I wanted to nicely print all of these variables in one table, address any anomalies if needed and have them in the appendix for my supervisors to review.

**The issue was, how can I nicely print all categorical variables along with the original question, the possible answers and the distribution of responses?**

First, let's look at our data:

```{r}
library(tidyverse) # dplyr, tidyr, readr & purrr
library(here) # Project management
library(readxl) # For reading excel files
library(knitr) # Printing tables
library(kableExtra) # Printing tables, but nice ones
library(janitor) # To clean names
df_survey <- read_xlsx(here("content", "post", "printing-categorical-variables-questions-with-kableextra", "data","survey.xlsx"))

head(df_survey)
```

So we have a lot of information regarding our sample \ data we collected. In order to nicely print all of our *character* columns, let's start by removing anything other than a character column:

```{r}
df_char <- df_survey %>% 
  janitor::clean_names () %>% 
  select_if(is.character) 
```

we'll need to change the data to a long form. A first thought the comes to mind is to use the `pivot_longer` argument so that we have everything in one nice long table:

```{r}
df_long <- df_char %>% 
  pivot_longer(q2:q37, names_to = "question") %>% 
  count(question, value) %>%
  group_by(question) %>% 
  mutate(pct = n/sum(n)*100)


knitr::kable(df_long) %>% 
  kableExtra::kable_styling() %>% 
  kableExtra::scroll_box(height = "400px")
```

Great, this prints nicely, but we're left with several issues to address:  

**1. We're missing the actual questions** -  Notice how we only have "q10_1" but not description of what the actual question or variable is.  

**2. Questions were reorganized alphabetically** - Once we ran the `pivot_longer` `R` sorted our new dataframe alphabetically according to the question variable, but we might want it ordered chronologically according to the survey. Of course this is contingent on your data, I wanted to show it aligned to the order of the survey questions. 

**3. Some of the responses aren't ordered** - Notice how some of the responses are randomly ordered, when ideally we'd want them to be ordered by hierarchy. For example question XXXXX

**4. Remove duplicated information** - Our column question, and if we add another with the text, will have duplicate information. While the value changes within questions, we don't need to show it's from that question only once. In addition, once we'll add the question title it'll be even more cluttered, so we'll have to deal with that.  


Let's address these issues and nicely finish up our table.

#### Adding information to our questions

When you download the survey data from Qualtrics you also receive it with the original questions. When I personally analyzed the data I removed it, but here it's perfect for providing additional information. If you don't have questions but variables, you can either skip this section or add information about the variables themselves.

To add the questions I found it pretty straight forward to just to combine the current data_long dataset with a dataset containing our questions. We'll use a copy of the original survey data that only contains the questions, let's have a look:

```{r}
df_questions <- read_xlsx(here("content", "post", "printing-categorical-variables-questions-with-kableextra", "data", "questions.xlsx"))
df_questions[,1:3]
```

Great, now let's turn it to a long format so that each row is a question id with the details of it as a value. Then we can join it with our current dataset of answers:

```{r}
df_q_clean <- df_questions %>% 
  clean_names() %>% 
  pivot_longer(cols = q2:q37, names_to = "question", values_to = "text") 

df_long <-  inner_join(df_long, df_q_clean, by = c("question" = "question"))

head(df_long)
```

Using the `inner_join` we kept only questions we want to display. Now let's turn to our second issue and address the order of our questions. Basically, we want it to be ordered by the value of the number itself and not how it's sorted alphabaetically (q11_1 before q_5). What we'll do, and there might be a quicker way, is use regex (regular expression) to use the number values to sort by. Here it goes:

```{r}
df_long_sorted <- df_long %>% 
  mutate(q_num = str_remove_all(question, "[a-z]"),
    q_num = str_replace_all(q_num, "_", "."),
    q_num = str_remove(q_num, "\\.$"),
    q_num = as.numeric(q_num)) %>% 
  group_by(question) %>% 
  arrange(q_num) %>% 
  select(-q_num)

head(df_long_sorted)
```

Perfect!  

We used some simple regular expressions to create a variable containing only our question number and sorted it by it. Now that we got that out of the way, let's head on to our next issue. Our next problem is that we want some of our questions to be organized not by the count or some randomness, but by hierarchy of the answer options, for example 'a few times a day', 'Once a day', 'several times a week' and so on.  
Personally, I didn't have a magicly automated answer but manualy provided levels to each answer. You can do this by setting them as a factor, or the way I did it: Create another table with the possible answer options and provide each answer with a value. You can then sort the answers by the order of numbers you provided, let's have a look:

```{r}

```




Alright! Much better!

### map & map_df

The issue we're facing also provides us with a great opportunity to explore [{purrr's}](https://purrr.tidyverse.org/) `map` and `map_df`. If we think back on what we just did, we basically aggregated all our columns into one so we can compute the frequency of each category. But what if instead of manipulating them when they're in one column, we manipulate each of the original columns?

