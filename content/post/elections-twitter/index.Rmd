---
title: Israeli elections on twitter
author: Amit Levinson
date: '2020-03-09'
slug: israeli-elections-on-twitter
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: '2020-03-09T19:29:42+02:00'
featured: no
draft: true
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
editor_options: 
  chunk_output_type: console
codefolding_show: show
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning = FALSE)
```

Israel just had its 3rd election in a row on March 2, 2020.
This is because our Knesset (Hebrew term for house of representatives) wasn't able to form or hold a government after the previous elections. As I won't get into the politics of why they didn't succeed thus far (get it? politics :wink:), I do want to take the opportunity and analyze some tweets posted in the time before and after the elections.

### Gathering the data <i class="fab fa-twitter"></i>

Twitter's API only always scraping for free 6-9 days back. therefore I scraped the data already on March 7, 2020 and saved it for later use. To gather the tweets we can use the `{rtweet}` package which is amazingly easy to use ([Check out its website](https://rtweet.info/)).  

Let's start with the packages we'll use:

```{r}
library(rtweet)
library(tidyverse)
library(tidytext)
library(hrbrthemes)
library(igraph)
library(ggraph)
library(scales)
```

```{r include = FALSE}
Sys.setlocale("LC_ALL", "Hebrew")
```


Next we'll gather the tweets we need:

```{r echo = FALSE}
# Not run
# elections_raw <- search_tweets(
#  "בחירות", n = 250000, retryonratelimit = TRUE
# )
elections <- readRDS("election_tweets.rds")
# elections <- election_tweets
```

As I mentioned earlier I already scraped the data to save it but wrote it here in case you're wondering how we gather them. I used only one term, which in Hebrew is "elections", and gathered all tweets using that word.

Before we begin, I will say this post doesn't aim to be representative of the discussions that were held during the election period. As a matter of fact, nor does it aim to be representative of the twitter discussion. this is due for several reasons:  
1. Twitter isn't common in Israel at all. I'm not sure what's the usage rate but it's definitely not representative of the Israel population.  
2. I searched for only one word - elections (in Hebrew) - which yielded some 16,000 tweets. This is definitely not a large enough dataset for a representation.

With that said, the data gathered provides an opportunity to look at some Twitter data from the elections period. 

### Let's begin

First, let's see how the tweets distribute across the time span we searched for. we can create a quick time plot using the `ts_plot()` from the `{rtweet}` package:
```{r}
elections %>% 
  ts_plot("2 hours")+
  geom_line(size = 1)+
  theme_ipsum_rc(plot_title_face = NULL)+
  scale_x_datetime(date_breaks = "1 day",date_labels = "%d %b")+
    labs(x= NULL, y = NULL,
       title = "Frequency of tweets throughout the Israeli elections",
       subtitle = "Tweets are counts aggregated using a two-hour interval.\nonly tweets with the word 'elections' (in Hebrew) were gathered")+
  geom_text(aes(x = as.POSIXct("2020-03-02 22:45:00"), y = 435, label = "10 PM:\nClosing of\npolls"),
            hjust = 0, size = 2.5)+
  geom_vline(xintercept = as.POSIXct("2020-03-02 22:00"),linetype = "dashed", size = 0.75)
```

Interesting, we see the number of tweets during the closing time is equivalent to that of March 4th early in the morning. Kind of an interesting anomaly which I can put my finger on, any suggestions?

### Users with most tweets

Next, let's look at who tweeted the most:
```{r, fig.width = 8}
elections %>% 
  count(screen_name, sort = T) %>% 
  slice(1:15) %>% 
  mutate(screen_name = reorder(screen_name,n)) %>% 
  ggplot(aes(x= screen_name, y= n))+
  geom_col(fill = "gray55")+
  coord_flip()+
  scale_y_continuous(breaks = seq(0,180, 30), labels = seq(0,180,30))+
  labs(x = "Screen name", y = "Number of tweets", title = "Top 15 users tweeting the word 'elections' during the 3rd Israeli elections")+
  theme_classic()+
  theme(text = element_text(family = "Calibri"),
        axis.text = element_text(size = 12),
        plot.title = element_text(family = "Roboto Condensed"))
```

We see that many news companies tweeted a lot using the word elections: 'newisrael13', 'kann_news', 'MaarivOnline', 'RotterNews', 'bahazit_news', 'RotterNet'. I don't פersonnaly recognize the rest, but on the other hand I use Twitter mostly to follow `R` and academic related tweets.

### Common Hashtags

When using the `{rtweet}` package to gather twitter data, one of the variables collected is the hashtags used in tweets. Although it requires a few lines of code to get them out of the text, I think this is an amazing feature that shows the details [Michael W. Kearney](https://mikewk.com/) put into the package.

According to [Wikipedia](https://en.wikipedia.org/wiki/Hashtag), a 'Hashtag' "is a type of metadata tag used on social networks such as Twitter and other microblogging services." that basically tags the message with a specific theme. This helps to see trends and themes in a macro level.

OK then, let's see what we have:

```{r}
hashtags <- elections %>% 
  select(hashtags) %>% 
  unlist() %>% 
  as.tibble() %>% 
  count(value, name = "Count", sort = T) %>%
  mutate(value = reorder(value, Count),
         iscorona = ifelse(value == "קורונה", "y", "n")) %>% 
  filter(!is.na(value)) %>% 
  slice(1:20)

ggplot(data = hashtags, aes(x = Count, y = value))+
  geom_col(aes(fill = iscorona), show.legend = FALSE)+
  theme_classic()+
  labs(y = NULL, x = "Number of Tweets", title = "Top 20 Hashtags associated with tweets addressing the Israeli elections")+
  scale_fill_manual(values = c(y = "dodgerblue4", n = "gray55"))+
  theme(text = element_text(family = "Calibri"),
        axis.text = element_text(size = 12),
        plot.title = element_text(family = "Roboto Condensed"))
```

The tweets include pretty much the basics with the two leading ones being 'elections' and 'elections2020'. I highlighted in blue an interesting hashtag at the time - <font color="blue"> Corona </font>. The elections were held on March 2, 2020, a little bit after the first cases reached Israel. Little did we know how it will affect us (I'm writing this post on April 07,2020 and we're still in quarantine heading to lock down.)


### Most liked and retweeted

Let's have a look at which tweet was **most liked**. Twitter doesn't define it as 'likes' but as 'favorite', or at least in the data that is collected through the {rtweet} package. Since I will want to do this again to get the tweet that was retweeted the most I'll create a function that will minimize re-writing the code.   
<br>
The function takes in a variable, reorders our dataset according to the variable we declared, extracts the first row and then pulls (also extracts) the status id of that tweet. Lastly, the `blogdown::shortcode` enables to embed tweets, youtube, etc., so we insert our status id in it. For those just getting into functions notice that within the `arrange` argument we insert our variable in two curly brackets {{}}. This is a powerful feature of `{rlang}` when you want to manipulate a variable in a dataframe within a function. Read more about it [here](https://www.tidyverse.org/blog/2019/06/rlang-0-4-0/)
```{r}
get_most <- function(var){
elections %>% 
  arrange(desc({{var}})) %>% 
    .[1,] %>% 
    pull(status_id) %>% 
  blogdown::shortcode('tweet',.)
}
```

<center> `r get_most(favorite_count)` </center>

So the tweet is by 'Amit Segal' - an Israeli news reporter- and it says: 
*"More than anything, I'm glad there won't be anymore elections for my family that suffered in honors a year and a quarter, Reut, Ivri and Inbar :heart_eyes:"*

Ha, interestingly he wrote it before the end of the elections. However he's right as we see today that a government was indeed formed so we won't have any elections soon (?).

Now let's look at the **most re-tweeted** tweet:


<center> `r get_most(retweet_count)` </center>

The tweet is by Benjamin Netanyahu, at the time the prime minister of Israel, that writes:
*"If the recording of Gantz's advisor is orcherstrated and fabricated (according to Gantz's words just now), so why did Gantz fire him?*
*Gantz's advisor was fired because he said the truth everyone knows: Gantz can't be a prime minister. We can. 2 more mandates to the Likkud and we are taking the country out of the plonter, prevent another election and form a government*

XXXXXXX


## Text Analysis

We did a little text analysis earlier on looking at some common Hashtags. However, I think we can do a little more than that. We'll look at two things:

1. A word-cloud  
2. Two-word (bi-gram) relationship
3. Distribution of words before and after the elections

### Wordcloud

In order to tackle the first thing, I'll break up all the tweets into words and filter Hebrew stop-words and any English words:

```{r include = FALSE}
```


```{r}
he_stopwords <- read_tsv("https://raw.githubusercontent.com/gidim/HebrewStopWords/master/heb_stopwords.txt", col_names = "word")

election_token <- elections %>% 
  unnest_tokens(word, text) %>% 
  select(word) %>%
  anti_join(he_stopwords) %>% 
  count(word, sort = T) %>%
  filter(n>= 150, !grepl("([a-z]+)|(בחירות)", word))
```

Let's review that for a minute:
1. I first read in a file containing 500 Hebrew stopwords. As to their validity, you can look at them for yourself [here](https://github.com/gidim/HebrewStopWords/blob/master/heb_stopwords.txt), I found it most suitable.  
2. I then used the unnest_tokens to break up the 'text' column in our dataframe into single words. We could, as we will do later, break it up into 2 words. Its default is one words which is adequate for in this case.  
3. I then `select` the only column we need - our new one.  
4. I use the `anti_join` to filter out *words that match* words in the stopwords dataset.
5. Using `count` count how many times each word occurs and sort it.
6. I `filter` any words that occur less than 150 times, the word 'elections' in Hebrew (Reminder: that's the word we searched tweets by so it'll be in all tweets) and any words in English. As to the latter, before I did it it left me with many Twitter usernames which didn't seem valuable.

Now we can look at our wordcloud using `{wordcloud2}`:
<br>
```{r}
wordcloud2::wordcloud2(election_token, color = "blue", shape = "circle")
```

### Bi-gram of used words

Like we did before, we can break up our text data into two words observations, also known as bi-grams. In order to account for all options, we break up the sentence to fit all possible options. For example, assume we have the following sentence:  
"Danny went to vote yesterday"  
Using the `unnest_tokens` we'll break the sentence up to become:
1. Danny went  
2. went to
3. to vote
4. vote yesterday

Which gives us all possible options. We will also include two columns consisting of the bi-gram broken up into single words. This will help in filtering out bi-grams containing Hebrew stop words. I'll not run through the following code and the next and instead will point you to [David Ronbinson](http://varianceexplained.org/) & [Julia Silge](https://juliasilge.com/) fantastic ['Text Mining with R' Book](https://www.tidytextmining.com/).

```{r fig.cap="Graph excludes Hebrew stop words and the word 'elections'"}
elec_bigram <- elections %>%
  select(text) %>% 
  unnest_tokens(bigram, text, token = "ngrams", n = 2) %>%
  separate(bigram, into = c("word1", "word2"), sep = " ", remove = FALSE) %>% 
  filter(!word1 %in% he_stopwords$word,
         !word2 %in% he_stopwords$word,
         !grepl("[a-z]|בחירות", bigram)) %>% 
  count(word1, word2, sort = T) %>% 
  slice(1:45) %>%
  graph_from_data_frame()

p_arrow <- arrow(type = "closed", length = unit(.1, "inches"))

ggraph(elec_bigram, layout = "fr")+
  geom_edge_link(aes(edge_alpha = n), arrow = p_arrow, end_cap = circle(.04, "inches"), show.legend = FALSE)+
  geom_node_point(color = "lightblue", size = 3)+
  geom_node_text(aes(label = name), vjust = 1, hjust = 1, family = "Calibri")+
  theme_void()+
  labs(title = "Bigram from Twitter data")+
  theme(text = element_text(family = "Calibri"),
        plot.title = element_text(hjust = 0.5 , face = "bold", size = 18))
```
<br>

So what are we looking at?  
- We have discussions regarding the number of chairs a govenrment will have (62/61/60/58) connected to mentions of the number of political campagins (2/3), discussions of united and limited government and the forming of in general.  
- We see mentions of individuals such as 'Yair Lapid', "Amir peretz", "Benjamin Netanyahu", "Amit Segal" (Both we discussed earlier), "Natan Eshel" **but no mention of the main candidate running against Netanyahu - "Benny Gantz"**. That's actually kind of odd so I ran the analysis again to search for Gantz and found that although he appears in 744 different bigrams, they all include different combinations of him!  
- We also see parties mentioned such as "Meretz", "Gesher" and "Labor" who ran together this time around, "Otzma Yehudit", "United Torah Judaism", and the "Joint List". **There's no mention of two leading parties - "Kahol Lavan" & "The Likkud".**, despite the mentioning of the latter's leader. This is inline with why Gantz doesn't appear - although the words appear many times, all combinations are somewhat different from one another.  
- Mentions of Netanyahu's indicment and the personal law connected to him.  
- Mentions I'd categorize as 'other' such as "Terrorist supporters", "Will of the people", "Fake news", "Last year", etc.
<br>
Actaully, this turned out more interesting than I thought.

### Words before and After the Elections

The last thing I'd like to look at is the frequency of words *before* and *after* the closing of polls. The elections were held on March 2nd, 2020, and the polls closed at 10:00 PM. Until 10 o'clock voting day it is prohibited to report and publicize any survey or media polls. Therefore, I imagine that at 10 PM (+- 30 seconds) when the media posts its first polls the discussion might vary a little. To check that we'll give each observation a value of before or after, break it up into words and plot their frequency. Let's have a look:

```{r}
election_freq <- elections %>% 
  mutate(tweet_time = ifelse(created_at < "2020-03-02 22:00:30", "before", "after")) %>% 
  select(text, created_at, tweet_time) %>% 
  unnest_tokens(word, text) %>% 
  filter(!grepl("([a-z])|בחירות", word),
         !word %in% he_stopwords$word) %>%
  count(tweet_time,word) %>% 
  group_by(tweet_time) %>% 
  mutate(proportion = n/sum(n)) %>% 
  select(-n) %>%
  pivot_wider(names_from = tweet_time, values_from = proportion)

ggplot(election_freq, aes(x = before, y = after, color = abs(before-after)))+
  geom_abline(color = "gray40", lty = 2)+
  geom_text(aes(label = word), check_overlap = TRUE, vjust = 1.5)+
  scale_x_log10(labels = percent_format())+
  scale_y_log10(labels = percent_format())+
  scale_color_gradient(limits = c(0, 0.001), low = "gray100", high = "gray25")+
  labs(title = "Frequency of words before and after the election polls",
       x = "Before", y = "After")+
  theme_classic()+
  theme(text = element_text(size = rel(4),family = "Calibri"),
        plot.title = element_text(family = "Roboto Condensed", size = 18),
        legend.position = "none",
        panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.line = element_line(color = "gray"))
```
<br>
<br>

All in all words seem extremely similar, let's run a correlation test to see how it looks:
```{r}
cor.test(election_freq$after, election_freq$before)
```

That's a pretty high correlation, in our case meaning that there are no extreme anomalies in using words. In other words, there isn't much of a difference in terms of words used before and after elections. We could run a term frequency inverse document frequency (tf-idf) instead of the above, but I'll leave that for another post altogether where I'll learn the algorithm.


```{r eval = FALSE}
candidates <- rtweet::get_timeline(c("netanyahu", "gantzbe"), n = 3200)

candidates %>%
  group_by(screen_name) %>% 
  rtweet::ts_plot(by= "1 week") +
  theme_minimal(base_family = "Roboto Condensed", base_size = 14)+
  scale_color_manual(values=c(gantzbe = "#56B4E9",netanyahu = "#E69F00"))+
  labs(title = "Tweet frequency for <span style='color:#E69F00'> Benjamin Netanyahu</span> and <span style='color:#56B4E9'> Benny Gantz </span> by week", x = NULL, y= NULL)+
  theme(
    plot.title = element_markdown(hjust = -0.2),
    panel.grid.major = element_blank(),
    panel.grid.minor.x = element_blank(),
    legend.position = "none"
  )

freq_candidate <- candidates %>% 
  select(text, screen_name) %>% 
  unnest_tokens(word, text) %>% 
  filter(!grepl("([a-z])", word),
         !word %in% he_stopwords$word) %>%
  count(screen_name,word) %>% 
  group_by(screen_name) %>% 
  mutate(proportion = n/sum(n)) %>% 
  select(-n) %>%
  pivot_wider(names_from = screen_name, values_from = proportion)


ggplot(freq_candidate, aes(x = gantzbe, y = netanyahu, color = abs(netanyahu-gantzbe)))+
  geom_abline(color = "gray40", lty = 2)+
  geom_text(aes(label = word), check_overlap = TRUE, vjust = 1.5)+
  scale_x_log10(labels = percent_format())+
  scale_y_log10(labels = percent_format())+
  scale_color_gradient(limits = c(0, 0.001), low = "gray100", high = "gray25")+
  labs(title = "Frequency of words before and after the election polls",
       x = "Gantz", y = "Netanyahu")+
  theme_classic()+
  theme(text = element_text(size = rel(4),family = "Calibri"),
        plot.title = element_text(family = "Roboto Condensed", size = 18),
        legend.position = "none",
        panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.line = element_line(color = "gray"))

library(ggtext)



cor.test(freq_candidate$netanyahu, freq_candidate$gantzbe)
```

