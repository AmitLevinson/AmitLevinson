---
title: An SQL interview question to learn from
author: Amit Levinson
date: '2021-07-08'
slug: a-great-sql-questions
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: ''
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: yes
draft: true
projects: []
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```


## The setting

During the first half of 2021, as I was finishing up my M.A. thesis, I started searching for a job in Data Analytics. [My journey into analytics was through learning R](https://amitlevinson.com/blog/my-year-in-r/) and I realized I had to learn some SQL, or at least familiarize myself with it.

Fast forward to interviewing, most of the SQL interview questions were pretty good. They checked if you could explain X or use other common operators something such as window functions, Having (though not common), LEAD, etc. There was one question I was really fond of and had thought about it since; this blog post details the question and several answers to it.


**An important caveat: The question and data do not represent my current employer.** The data used here is made up and the question came from a different company. 

Note that I'll be using R to setup an SQL connection in memory but power through with SQL. While not necessary, some SQL knowledge is useful to understanding the answers' syntax.

## The Interview question

So here it goes:

> Let's say you have a table of sellers' (henceforth: users) payments. The table has the user's name, date of payment and the amount they received. Users have multiple records with different amounts and dates. You are asked for each user to return the user name, the maximum amount they received and the date of that payment.

> And now for the second part: Now that you've solved it, solve it again using a different approach.

For a more practical example (though the interview didn't have one), considering the following raw data:

```{r}
library(dbplyr)
library(dplyr)
library(gt)
library(tibble)


# create the data
payments <- tribble(
  ~user,    ~payment_date,    ~amount,
  "Danny",  "2021-07-05",     42,
  "Danny",  "2021-05-12",     62,
  "Danny",  "2021-08-01",     80,
  "Danny",  "2021-06-12",     87,
  "Alice",  "2021-07-03",     60,
  "Alice",  "2021-05-29",     72,
  "Alice",  "2021-05-12",     85,
  "Alice",  "2021-06-24",     45,
  "Tom",    "2021-06-28",     80,
  "Tom",    "2021-07-12",     56,
  "Tom",    "2021-07-19",     95,
  "Tom",    "2021-05-11",     75
) %>% 
  mutate(payment_date = as.character(payment_date))


conn <- src_memdb()
conn_code_chunks <- conn$con
copy_to(conn, payments, overwrite = TRUE)

# Close connection
# DBI::dbDisconnect(conn_code_chunks)
```


```{r, fig.align = 'left'}
raw_payments <- payments %>% 
  arrange(user, amount, payment_date)


gt(raw_payments) %>% 
    tab_style(
      style = cell_fill(color = 'lightgreen'),
      locations = cells_body (
        rows = c(4,8,12)
      )
    )

```

Return the following table:

```{r, fig.align='center'}
payments %>% 
  group_by(user) %>% 
  filter(amount == max(amount)) %>% 
  ungroup() %>% 
  gt()
```

```{sql connection=conn_code_chunks, echo = TRUE}
SELECT USER,
  payment_date,
  MAX(amount)
FROM payments 
GROUP BY User
```


All right. So we know what we have to do. But before we do it, let's see how not to do it.

### Why not just a simple GROUP BY?

An immediate question that might come to mind is why not use a simple `GROUP BY` and return the `MAX` value. I.e., just filter each group by the max value according to one of the variables.  

The issue is when we use `GROUP BY` we retrieve only the information that is aggregated. That is, if we group by the sellers name and return the max we only get those two columns -- User and max amount (without the date). Alternatively, if we `GROUP BY` the User, date and return the `MAX` value we'll get the information for each User and date (considering we have distinct dates for each user).

For example, let's show both approaches here:

```{sql connection=conn_code_chunks, echo = TRUE}
SELECT USER,
  MAX(amount)
FROM Payments 
GROUP BY User
```




```{sql connection=conn_code_chunks, echo = TRUE}
SELECT User,
  Payment_Date,
  max(amount)
FROM payments
GROUP BY User

```




SHOW BOTH Queries

  - various questions
  
  - Not representing my employer

  - Some basic knowledge of SQL (or R also if you ask me) can help


## Solutions

### 1. Window functions

The first solution that might come to mind is using a Window Function. If you don't know them, I suggest you familiarize yourself. To borrow from [PostgreSQL's description](https://www.postgresql.org/docs/9.1/tutorial-window.html), a window function "performs a calculation across a set of table rows that are somehow related to the current row". In different from aggregate operations (sum, avg, etc), using window functions doesn't cause rows to become grouped into single row outputs.  

We can use the window function `[DENSE_RANK()](https://docs.microsoft.com/en-us/sql/t-sql/functions/dense-rank-transact-sql?view=sql-server-ver15)`/`RANK()`[^1] to retrieve the rank of each value for a user within a sub-query, and extract the relevant row with an outer query:

[^1]: One reason I'm not going for ROW_NUMBER here is that were interested in the top value that could have multiple appearances for a user. ROW NUMBER will only give us one value, here I'm interested in the max value that could appear several times.

```{sql connection=conn_code_chunks, echo = TRUE}
SELECT user, Payment_Date as 'Payment Date', amount
FROM (
  SELECT *,
    DENSE_RANK() OVER(Partition BY User Order by amount DESC) as rnk
  FROM payments)
WHERE rnk = 1;  
```

OK, that was pretty straight forward. But the interview question doesn't end there but asks for another approach. Let's move on.

### 2. Self Join

`JOIN` are key functions when querying data. Considering the large amount of data a company has, and the normalization procedures it does you'll be expected to join a lot. In this specific case we can leverage the arithmetic features of a `JOIN` to retrieve the relevant value.


```{r}
test <- tbl(conn, sql("
SELECT p.user, p.payment_date, p.amount
FROM payments p
LEFT JOIN payments pp ON p.user = pp.user
  AND p.amount < pp.amount
WHERE p.amount NOT BETWEEN 0 AND 100"))
```


```{sql connection=conn_code_chunks, echo = FALSE}
-- This Code chunk is just because I'm having issues running the self-join and filter NULL values in R.
-- essentially the WHERE should bw "WHERE pp.amount IS NULL" 
SELECT DISTINCT p.user, p.payment_date, p.amount
FROM payments p
LEFT JOIN payments pp ON p.user = pp.user
  AND p.amount < pp.amount
WHERE p.amount IN (85, 87, 95);
```


```{sql eval = FALSE, echo = TRUE}
SELECT DISTINCT p.user, p.payment_date, p.amount
FROM payments p
LEFT JOIN payments pp ON p.user = pp.user
  AND p.amount < pp.amount
WHERE pp.amount IS NULL;
```

While we're all familiar with a 'regular' `* JOIN` using an equality sign `=`, we can check for *inequality* such as smaller than `<`. Essentially we do a cartesian join of the table on itself by user, and then filter rows where values (p.amount) are smaller than other values (pp.amount). Our max value won't find any relevant rows to join, considering it's not smaller than anything, which will result with a `NULL` value we can use to filter. If you want to see the the intermediate step just remove the `WHERE` clause and select all columns.

### 3. Correlated subquery

We've come to my final approach for this blog post. Thought not requested, I thought of this approach only after the interview and thought of sharing it. I've come to like Correlated subqueries since learning them, as I find them somewhat similar to vectorized operations in `R` such as the apply family and the `purrr` library.

A correlated subquery is a row-by-row process, in which each subquery is executed once for the outer query (adapted from [GeeksforGeeks](https://www.geeksforgeeks.org/sql-correlated-subqueries/)). Let's look at the answer and explain it more clearly:


```{sql connection=conn_code_chunks, echo = TRUE}
SELECT User,
  Payment_Date,
  amount
  FROM Payments p
  WHERE amount = (SELECT MAX(amount)
                          FROM Payments pp
                          WHERE pp.User = p.User -- Notice the relation to the parent table
                          )
  GROUP BY User;
```

To easily read the query and understand correlated subqueries, let's start from the inside. From the payments tables where the User is equal to the user in the outer query, grab the maximum amount. Now the outer query goes *row by row for each user* and compares whether that rows' amount is equal to that user's max amount retrieved from the inner query. In other words, for each user the outer query goes row by row comparing its value to the inner query result which doesn't change.

### Closing remarks

This was a pretty short post on some SQL approaches to solving a question. You can probably think (or thought) of different approaches which is also great, or of the same idea but different syntax. At the end I did feel like this question required me to utilize different SQL code to solve the same question so I'm glad I came across it. I didn't get the job but that's OK. Eventually that's how I ended up where I am today :)

Hope you find this useful and learned something new!


