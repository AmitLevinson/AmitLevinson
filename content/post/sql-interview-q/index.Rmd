---
title: An SQL interview question to learn from
author: Amit Levinson
date: '2021-07-08'
slug: a-great-sql-questions
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: ''
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: yes
draft: true
projects: []
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r}
```


Structure:

## Intro

- Intro on job search process

During the first half of 2021, as I was finishing up my M.A. thesis, I started searching for a job in Data Analytics. [My journey into analytics was through learning R](https://amitlevinson.com/blog/my-year-in-r/) and I realized I had to learn some SQL, or at least familiarize myself with it.

Most of the SQL interview questions were pretty good. They cheked if you knew how to solve A or use something such as a window function, Having, LEAD, etc. But one question I was really fond of and thought about it since; this blog post details the question and several answers to it.

**The question and data do not represent my current employer.** The data used here is made up and the question came from a different company. While not necessary, some SQL knowledge is useful to understanding the answers' syntax.

## The Interview question

Let's say you have a table with payments information. The table has users' names, the date of their last payment and the amount they received. For each seller, return their name, the last date of their payment and the amount received on that date. I'll be using R to setup a connection in memory but power through with SQL for the rest of the post.

Now to our question, Considering the following raw data:

```{r}
library(dbplyr)
library(dplyr)
library(gt)
library(tibble)


# create the data
payments <- tribble(
  ~user,    ~payment_date,    ~amount,
  "Danny",  "2021-07-05",     42,
  "Danny",  "2021-05-12",     62,
  "Danny",  "2021-08-01",     80,
  "Danny",  "2021-06-12",     87,
  "Alice",  "2021-07-03",     60,
  "Alice",  "2021-05-29",     72,
  "Alice",  "2021-05-12",     85,
  "Alice",  "2021-06-24",     45,
  "Tom",    "2021-06-28",     80,
  "Tom",    "2021-07-12",     56,
  "Tom",    "2021-07-19",     95,
  "Tom",    "2021-05-11",     75
) %>% 
  mutate(payment_date = as.character(payment_date))


conn <- src_memdb()
conn_code_chunks <- conn$con
copy_to(conn, payments, overwrite = TRUE)

# Close connection
# DBI::dbDisconnect(conn_code_chunks)
```


```{r, fig.align = 'left'}
raw_payments <- payments %>% 
  arrange(user, amount, payment_date)


gt(raw_payments) %>% 
    tab_style(
      style = cell_fill(color = 'lightgreen'),
      locations = cells_body (
        rows = c(4,8,12)
      )
    )

```

return the following table:

```{r}
payments %>% 
  group_by(user) %>% 
  filter(amount == max(amount)) %>% 
  ungroup() %>% 
  gt()

DBI::dbGetQuery(conn, "SELECT USER,
  payment_date,
  MAX(amount)
FROM payments 
GROUP BY User")


```

```{sql connection=conn_code_chunks, echo = TRUE}
SELECT USER,
  payment_date,
  MAX(amount)
FROM payments 
GROUP BY User
```


All right. So we know what we have to do. But before we do it, let's see how not to do it.







```{sql connection=conn_code_chunks, echo = TRUE}
SELECT User,
  Payment_Date,
  amount
  FROM Payments p
  WHERE amount = (SELECT amount
                          FROM Payments pp
                          WHERE pp.User = p.User -- Notice the relation to the parent table
                          ORDER By amount DESC
                          limit 1)
  GROUP BY User;
```

### Why not just a simple GROUP BY?

An immediate question that might come to mind is why not use a simple `GROUP BY` and return the `MAX` value. I.e., just filter each group by the max value according to one of the variables.  

The issue is when we use `GROUP BY` we retrieve only the information that is aggregated. That is, if we group by the sellers name and return the max we only get those two columns -- User and max amount (without the date). Alternatively, if we `GROUP BY` the seller and product name and return the `MAX` value we'll get the information for each seller and every product of theirs.

For example, let's show both approaches here:

```{sql connection=conn_code_chunks, echo = TRUE}
SELECT USER,
  MAX(amount)
FROM Payments 
GROUP BY User
```




```{sql connection=conn_code_chunks, echo = TRUE}
SELECT User,
  Payment_Date,
  max(amount)
FROM payments
GROUP BY User

```




SHOW BOTH Queries

  - various questions
  
  - Not representing my employer

  - Some basic knowledge of SQL (or R also if you ask me) can help


## Solutions

### 1. Window functions

One solution that might come to mind is using a Window Function. If you're not familiar with them, I suggest you do learn a little more about them. To borrow from [PostgreSQL's description](https://www.postgresql.org/docs/9.1/tutorial-window.html), "A window function performs a calculation across a set of table rows that are somehow related to the current row.". In different from aggregate oeprations (sum, avg, etc), using window functions doesn't cause rows to become grouped into single row outputs.  

We can use the window function `[DENSE_RANK()](https://docs.microsoft.com/en-us/sql/t-sql/functions/dense-rank-transact-sql?view=sql-server-ver15)`/`RANK()` to retrieve the rank of each value within each user in a sub-query, and extract the relevant row from the outer query:

```{sql connection=conn_code_chunks, echo = TRUE}
SELECT user, Payment_Date as 'Payment Date', amount
FROM (
  SELECT *,
    DENSE_RANK() OVER(Partition BY User Order by amount DESC) as rnk
  FROM payments)
WHERE rnk = 1;  
```

OK, that was pretty straight forward. But the interveiw question doesn't end there but ask for another approach. Let's move on.

### 2. Self Join

`JOIN` are key functions when querying data. Considering the large amount of data a company has, and the normalization procedures it does you'll be expected to be doing a lot of joins. In this specific case we can leverage the arithmetic features of a `JOIN` to retrieve the relevant value.

While we're all familiar with the regular `JOIN` using the equality sign `=`, we can also use it check for inequality, or as I'm interested here, using a smaller than -- `<`. We can do a cartesian join of the table on itself by the user and by values that are smaller than other values. our max value won't find any relevant rows to join (considering it's not smaller than anything), which will result with a `NULL` value we can use to filter. 

```{r}
tbl(conn, sql("
SELECT *
FROM payments p
LEFT OUTER JOIN payments pp ON p.user = pp.user
  AND p.amount < pp.amount
WHERE pp.amount NOT BETWEEN 0 AND 100"))
```



```{sql connection=conn_code_chunks, echo = TRUE}
SELECT *
FROM payments p
LEFT OUTER JOIN payments pp ON p.user = pp.user
  AND p.amount < pp.amount;
WHERE pp.user NOT IN ('Danny ');
```


### 3. Correlated subquery

