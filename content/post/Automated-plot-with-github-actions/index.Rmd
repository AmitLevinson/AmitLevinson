---
title: A Taste of GitHub Actions with an Automated Plot
author: Amit Levinson
date: '2020-12-31'
slug: Automated-plot-with-github-actions
categories: [R]
tags: [TidyTuesday, GitHub]
subtitle: ''
summary: 'Trying out GitHub actions by automatically rendering a plot depicting frequently used packages in a repository.'
authors: []
featured: yes
image:
  caption: 'Image by Pixabay'
  focal_point: ''
  preview_only: yes
projects: []
draft: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```


```{r, echo = FALSE, fig.cap='Final output of a plot automatically updating on a specific git commit.', fig.align='center'}
knitr::include_graphics("plot.png")
```

### Preface

**TL;DR**: In this post we setup the code for having a GitHub Action automatically update a plot. I start by showing how to plot my most frequently used R packages for Tidytuesday. I then setup the code for A GitHub Action to automatically render the plot on a specific commit, and reference it from my repository's README file.

Before we begin, I want to thank [Rami Krispin](https://ramikrispin.github.io/) and [Michael Dorman](https://geobgu.xyz/). I contacted Rami a while back asking for advice on working with GitHub Actions. Rami was forthcoming in helping if any problems arose and saved me a lot of frustration.

As to Michael, I thank him for the example I use in the post to try out GitHub Actions. A while back Michael posted in an Israeli R Facebook group a plot detailing the packages he frequently uses ([here'sa gist with the script](https://gist.github.com/michaeldorman/ad8d89136f03769105ccc6199a913f0b?fbclid=IwAR09u1WFD9YpKYb7nvezOKqGGZac3AuVWC7ogDItSv9sXXS0x2KpYxg3aU0) ). When thinking of how to try out GitHub actions I thought replicating it would be a great example, only adding an automation as a twist. 

Speaking of automation, let's dive in!

![](https://media.giphy.com/media/XCxcmEQWxDdc8qsd2R/giphy.gif)

### Why automate?

To answer that let's start with understanding what GitHub Actions are. Taken from GitHub's website:

> Automate, customize, and execute your software development workflows right in your repository with GitHub Actions. You can discover, create, and share actions to perform any job you'd like, including CI/CD, and combine actions in a completely customized workflow.

I first heard about GitHub Actions in regards to package checks, enabling package developers to run continuous integrations, unit tests and the like automatically. **One can have GitHub run a script when a Git action occurs (e.g. a push or pull request), or at a specific time slot in the day/week/month.** 

Reading up on various things you can automate made me eager to try it out - **Automating a script to run every Sunday morning, sending an email, or hosting an [interactive graph online](https://amitlevinson.com/post/sharing-interactive-charts/).** Another example that got me motivated to learn was [Emil Hvitfeldt's](https://www.hvitfeldt.me/) awesome paletter [bot](https://twitter.com/BotPaletteer). A Twitter bot that automatically tweets color palette packages once a day.

<center>
`r blogdown::shortcode('tweet','1340376626853535745')` 
<newcaption>[Emil Hvitfeldt's](https://www.hvitfeldt.me/) Twitter bot tweeting color palettes once a day using GitHub Actions</newcaption>
</center>  

## My TidyTuesday packages

In this post I'll go through creating the infrastructure to automatically updating a plot I present in my TidyTuesday GitHub README file. In short, #Tidytuesday is an awesome weekly data project where individuals analyze and visualize new data every week. You can find more info on the [project's Github page](https://github.com/rfordatascience/tidytuesday), or [about how it helps me in my journey of learning R](https://amitlevinson.com/post/my-year-in-r/).

When participating in Tidytuesday, I open a new R session for each new project. A new session each week results in the creation of multiple R files, and more relevant to us, the packages we used each session. Therefore I thought to myself why not showcase my frequently used packages, and have it automatically update?

Quick side note: if you just want to visualize your #TidyTuesday code without any GitHub Actions, I highly recommend exploring [Georgis Karmanis](https://karaman.is/) [Tweet](https://twitter.com/geokaramanis/status/1334437358519902209) and code. There he used the `{textreadr}` package which does a lot of the heavy lifting reading in and cleaning the files we'll be doing below. I came across his tweet after completing the analysis here and decided to leave as is, since it helps me better understand what happens 'under the hood'.

### Reading the files

Michael's original plot as an inspiration for the example to use with GitHub Actions is fantastic. However, what's a blog post without some challenges and tears; therefore, we'll replicate the same idea with a tidyverse approach.

```{r}
library(purrr)
library(stringr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(forcats)
library(extrafont)

# Ideally, use the here package and not complete paths
tt_path <- "C:/Users/amitl/R_code/tidytuesday"
files <- list.files(path = "C:/Users/amitl/R_code/tidytuesday", pattern = "\\.R$|.Rmd$", recursive = TRUE)
files <- files[-length(files)]
```

First and most important, I recommend using R projects and the [{here}](https://github.com/jennybc/here_here) package by [Jennifer Bryan](https://jennybryan.org/) for file management. The only reason I'm using a direct path is because when writing this post my R session assumes I'm within my website directory, making it a challenge to move between project roots[^1]. We started by listing all files ending in `.R` or `.Rmd` in that specific path, also searching through sub-folder using `recursive = TRUE`. I then filter the last element of the vector because that's the code file I use to produce the plot. 


[^1]: If you decide to automate this with GitHub Actions, be alert if file paths throw an error.

Let's look at what we have:  

```{r}
head(files)
```

We see the R scripts I used to produce my Tidytuesdays. Unfortunately, it also returns R scripts I opened but didn't completely follow through with the analysis. That is, sometimes I worked on a TidyTuesday but stopped and left it incomplete without producing a plot (shame on me). There's not that many of them and for the purpose of the exercise we'll leave them there. 

Before we dig in I want to get the names of the files. It's  not required for the analysis, but I found in nicer to look at the packages used corresponding to where they came from.

```{r}
# Get names
file_names <- str_extract(files, '[^/]+(?=\\.)')

head(file_names)
```

Our original string was "`r files[1]`", and we want everything after the last `/` - "National Parks.R". We can achieve this using some regular expressions (regex) `[^/]+` and a positive look ahead `(?=\\.)` to capture everything between the last backslash and a period. Voila, our final output of "`r file_names[1]`", my first #TidyTuesday R script.   

Now we can read in the text from all these R scripts:

```{r}
tt_path <- paste0(tt_path, "\\/" ,files)
file_lines <- map(tt_path, readLines)

head(file_lines[[1]])
```

After creating a complete path of our scripts we iterated across them using `map` and the function `readLines`. Essentially, you can read `map` as follows: Run function `readLines` on every element of vector `tt_path` (The vector containing our path to each `.R`/`.Rmd` script). For a better understanding of the `map` function and family I highly recommend exploring the [documentation](https://purrr.tidyverse.org/reference/map.html). As to our output, notice that the line breaks from the original code scripts are preserved. That means that every line represents a code that was run. 

### Cleaning

If my memory is correct, I mainly use functions either by loading the library through `library()` or reference specific argument with `library::`. We'll capture both using some regex and return them as a dataframe:

```{r}
names(file_lines) <- file_names
file_packages <- map_dfr(file_lines, ~ tibble(package = str_extract(.x, "((?<=library\\().+(?=\\))|\\w+(?=::))")),
  .id = "tidytuesday") %>% 
  filter(!is.na(package)) %>% 
  distinct(tidytuesday, package)

head(file_packages)
```

Perfect! First I added the original script names for each sub list within the `file_lines`. As to the analysis Let's tackle each element at a time from the inside out, starting with the regular expressions.

We can split the regex into two parts. the first one `(?<=library\\()).+(?=\\())` is both a positive look behind capturing everything after `library\\(` until it reaches `(?=\\))`, a positive look ahead for a parentheses. That way we capture everything in between the parentheses but remove `library()` text. The second section of the regex `\\w+(?=::))` mimics the previous one but this time only with a positive look ahead -- Capture the word (`\\w+`) before the two `::`. 

We iterate the `str_extract` across each sub-list of our `file_lines` object containing all our R scripts using `map_dfr` to return a tibble. Since it returns a a data frame format we can provide a column name - `package`. In addition, `map_df*` (map_df, map_dfr, etc.) can take an `.id` argument that will return the names of the original sub-lists as a column.

After filtering any `NA`, that is words that didn't match our regex such as empty lines, I used `distinct` to remove duplicate packages in each week. For example, if I called `stringr::` twice in an R script.  

An issue that's left is when calling `tidyverse` essentially we load packages such as `readr`, `ggplot2`, etc. We see that `readr` dominates the plot of packages because I call it explicitly when loading the data, compared to ggplot2 I only call from the `tidyverse`. So do I want to leave `readr` or remove it if I already call `tidyverse`? Here I leave it as is, but feel free to find a workaround it.

### plot

We're at the last part of reading-processing-plotting journey. The plot is pretty straight forward and I invite you to explore other plots if you wish to produce different outputs. Remember though that you want it to automatically update, so make sure you create something that won't throw any errors requiring you to constantly return to the code.

```{r}
# Uncomment if you use it in a GitHub Action
# library(showtext)
# font_add_google("Roboto Condensed", "Roboto")
# showtext_auto()

file_packages %>% 
  count(package, sort = T) %>%
  slice(1:15) %>% 
  ggplot()+
  geom_col(aes(y= fct_reorder(package,n), x = n), fill = "gray45")+
  labs(title = "Frequently used packages in #Tidytuesday",
       subtitle = "Plot is rendered on every 'initial commit' to this repository, showcasing my 15 most frequently\nused packages in #TidyTuesday",
       x = "Number of times used", y = "Package name",
       caption = paste0("Last updated:\n",format(Sys.Date(), "%b %d, %Y")))+
  theme_minimal()+
  theme(
    text = element_text(family = "Roboto Condensed"),
    plot.title = element_text(size = 18),
    plot.title.position = "plot",
    plot.subtitle = element_text(size = 11, color = "gray20"),
    plot.caption = element_text(size = 8, color = "gray30", face = "italic"),
    axis.title = element_text(color = "gray40", size = 9),   
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 11),
    panel.grid.major.y = element_blank(),
    plot.margin = unit(c(4,2,2,4), "mm")
  )

# Save somewhere you'll reference later
# ggsave ("extra/packages-used.png")
```

A few specific things to note:  

1. In the GitHub Action I use [`showtext`](https://github.com/yixuan/showtext) as it enables to load a font that's not currently installed on the computer. You might need to play around with the text size if you use this package, as the appearance of graphs might vary across operating systems. Here I used the`{extrafont}` package along with Roboto font, since for some reason showtext wasn't properly rendering in this blog post.

2. I decided to only take the top 15 frequently used packages. You can play around with it to find a number you like or one that properly fits.

3. I automated the caption to print the current date on every render, i.e. every time we push to our #TidyTuesday repository and activate the GitHub Action.


## GitHub Actions

*See additional learning resources below*

![](https://media.giphy.com/media/CmFMWpEa4IFtS/giphy.gif)

GitHub actions provide an easy way to automate various *workflows*. Essentially we provide GitHub a set of instructions on when to run the Action, and what exactly does it need to do. Instructions are aggregated as a script, in our case a 'YAML' file (Yet Another Markdown Language) with specific commands. For the purpose of this post, and if you don't use GitHub Actions frequently, you should be good with the free plan (default unless you subscribed). In any case, you can read more about the plans [here](https://docs.github.com/en/free-pro-team@latest/github/setting-up-and-managing-billing-and-payments-on-github/about-billing-for-github-actions)). 

We have our plot showcasing our most frequently used packages, but we want it rendered on every participation in #TidyTuesday. That's exactly where GitHub Actions can help us by running the script for us. We setup the code once, like we did before, and have our workflow run it when we choose.

### Action Setup 

We'll use the `usethis` R package to create the Action workflow. The package makes it easy to work with GitHub Actions by providing great `yaml` templates and folder setups. Alternatively, you can create a workflow yaml file yourself through the 'Actions' tab in your repository. I found `usethis` `README.Rmd` template adequate so we'll create that. Assuming you have the package installed, just type the following in the r console in the root folder of your #Tidytuesday repository (or whatever repository you want the Action to run on):  


```{r eval = FALSE}
usethis::use_github_action()
```

And you should receive the following output, only with your information instead:

```{yaml, eval = FALSE}
√ Setting active project to 'C:/Users/amitl/R_code/TidyTuesday'
√ Creating '.github/'
√ Adding '^\\.github$' to '.Rbuildignore'
√ Adding '*.html' to '.github/.gitignore'
√ Creating '.github/workflows/'
√ Writing '.github/workflows/R-CMD-check.yaml'
* Copy and paste the following lines into 'C:/Users/amitl/R_code/TidyTuesday/README.md':
  <!-- badges: start -->
  [![R build status](https://github.com/AmitLevinson/TidyTuesday/workflows/R-CMD-check/badge.svg)](https://github.com/AmitLevinson/TidyTuesday/actions)
  <!-- badges: end -->
```

Perfect. We're not going to copy the lines suggested as they're helpful for package checks, and we're only interested in producing a plot. The important outcome for us from running the line is the newly produced output under `./github/workflows/R-CMD-check.yaml`. We're going to use that yaml file to write up what we want GitHub to do.  

I will not go through what the file currently contains, due to lack of space and my knowledge of everything there. Instead I'll provide you with the script I used and we'll review that. Also, feel free to rename the worflow file, as long as it's a `yaml` file under the `workflows` directory GitHub will process it as an Action automatically. no further setup is needed, unless you want to use 'secretes' such as confidential API keys (More on scretes [here](https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/security-hardening-for-github-actions#using-secrets).

Below are the instructions we implement in our yaml file:

```{yaml, eval = FALSE}
name: Render library update

on: [push]

jobs:
  build:
    runs-on: macOS-latest
    if: "contains(github.event.head_commit.message, 'initial commit')"
    steps:
      - uses: actions/checkout@v2
      - uses: r-lib/actions/setup-r@v1
      - name: Install packages
        run:
          Rscript -e "install.packages(c('tidyverse', 'showtext'))"
      - name: Render r plot file
        run:
          Rscript -e "source('packages-plot.R')"
      - name: Commit results
        run: |
          git config --local user.email "actions@github.com"
          git config --local user.name "GitHub Actions"
          git add extra/packages-used.png
          git commit -m 'Re-build package plot' || echo "No changes to commit"
          git push origin || echo "No changes to commit"
```

### What's all this yaml

Let's break break up the script piece by piece:

* `name: Render library update` - The name of the the GitHub Action. This is what will appear under the workflows section in the GitHub actions tab.

* `on: [push]` - Tells GitHub when to activate the workflow. There's a plethora of options to use here; for example, you can have it run on every commit, a pull request or both. In addition, you can have it run at a specific time frame using `schedule`.

* `jobs: build:` - I'm not sure what exactly they do. I know that for rendering README files you'd have `render` instead of build, but honestly I don't know what either does exactly.

* `runs-on: macOS-latest` This tells GitHub on which operating system to run the r environment. Essentially you can even choose a few such as Ubuntu, Windows, etc. It can be extremely useful when you're checking out packages and want to verify they work on various operating systems. I use on my own computer Windows and left it with `macOS-latest`.

* `if: "contains(github.event.head_commit.message, 'initial commit')"` - Here we provide GitHub an 'exit' condition when running the Action, and the condition on when to run it. `github.event.head_commit.message` captures the commit message you used before pushing. We then check whether it matches a regex we provided, in this case 'initial commit'. Without a logical condition, the Action will follow through on every push.

{{% alert note %}}
We use a conditional statement to tell GitHub when to run our Action. If the condition returns true, in this case matching our commit message, GitHub Actions will complete the workflow. Otherwise the Action will stop and exit before processing the following steps. 
{{% /alert %}}

* `steps...` - Telling GitHub the exact steps we want the action to do. The script starts with `uses` and then transitions between `name` and `run`.   
`uses` tells GitHub what to use: In the first one, `actions/checkout@v2`, GitHub checks out a copy of our repository on which the workflow will run. We set the 'fetch-depth' to 2 so the Action collects the relevant info it needs from the repository (not sure exactly what, but with 1 won't suffice. You can read more about it [here](https://github.com/actions/checkout#usage)). Next we set up a remote r environment using the `r-lib/actions/setup-r@v1` argument (Again, read more about it [here])(https://github.com/r-lib/actions/tree/master/setup-r).  

* In the following steps we provide a name for the step and the actual code. In the first step we install the packages we'll be using and in the next one we `source` the R code that produces our plot[^2]. Lastly we provide Git commands in which we add our rendered plot (notice that I save it in a sub-folder), commit and push the results. I'm not too sure about the 'user.email' and 'user.name' arguments so I left them as is.

[^2]: The more dependencies you have, the more susceptible your code is to breaking, e.g. if a function was deprecated.

That's it! Just upload the newly edited files, and activate the Action with the specific commit. Don't forget to reference it from your repository's README so it shows up.

```{r, echo = FALSE, fig.cap='Succesfull GitHub Action detailing the process, found under the Actions tab', fig.align='center'}
knitr::include_graphics("success.png")
```


When the Action is running you will see an orange dot at the top of the root folder of your repository. Once it's complete it should turn green if all went well, or red if not. After it finishes give it a few minutes as it might take some time until the plot is actually updated. You can explore this action in [my #Tidytuesday repository](https://github.com/AmitLevinson/TidyTuesday).  

{{% alert warning %}}
If the above GitHub Action follows through with the workflow and produces a new plot, it will only be updated in your remote repository. You might be required to merge the remote content locally next time you want to push.
{{% /alert %}}

In order to debug, for example if the orange dot turn to a red x, go into the 'Actions' tab in your repository, click on 'Render library update' or however you called the action -> click on the last commit message -> 'build' and then you should see a list of actions GitHub took. Try to identify where it stopped by locating the red x it marked the break with. Unfortunately debugging is a post in and of itself, and I'm not definitely the one to write it.

**Disabling:** If you wish to disable the GitHub Action, you can either remove the `.yaml` file or disable the action from the repository's settings.

```{r echo = FALSE, fig.cap='our final outcome automatically updating in our README file.'}
knitr::include_graphics("outcome.png")
```

### Closing remarks

This was my first time around using GitHub actions and hopefully not the last. I used here only one example, and might be a little niche for some people, but I hope you got the big picture -- GitHub Actions are easy to use, and they can automate a lot of your work. Do let me know if you made an Action as a result of reading the post, I would love to see what you came up with.  

You can find the complete R script I used [here](https://github.com/AmitLevinson/TidyTuesday/blob/master/packages-plot.R), and the YAML script for the GitHub Action [here](https://github.com/AmitLevinson/TidyTuesday/blob/master/.github/workflows/render-plot.yaml). 

Lastly, I would like to highlight several resources I found useful for learning more about GitHub Actions and for you to explore:

1. Jim Hester's [rstudio talk](https://www.jimhester.com/talk/2020-rsc-github-actions/) on GitHub actions - Great introduction and to get you excited about the opportunities available with GitHub Actions. 

2. Gavin Simpson's blog post ['Rendering your README with GitHub Actions'](https://fromthebottomoftheheap.net/2020/04/30/rendering-your-readme-with-github-actions/) - A more hands-on approach on setting everything up to learn more about the `yaml` we write, and how to implement it in a README file.

3.  As I was finalizing this blog post I noticed Simon Couch published a fantastic blog post on using [GitHub actions to run an R script on a schedule](https://blog.simonpcouch.com/blog/r-github-actions-commit/). 

That's it for now. Hope you enjoyed this blog post and found it useful!