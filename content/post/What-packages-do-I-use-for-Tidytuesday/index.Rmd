---
title: Github actions with Tidytuesday packages
author: Amit Levinson
date: '2020-07-09'
slug: Identifying-packages-used-for-Tidytuesday
categories: [R]
tags: [TidyTuesday, GitHub]
subtitle: ''
summary: 'Trying out GitHub actions by automating a rendering of a plot of what packages I use and how many'
authors: []
featured: yes
image:
  caption: 'Image by Pixabay'
  focal_point: ''
  preview_only: yes
projects: []
editor_options: 
  chunk_output_type: console
draft: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE)
```

Thank you very much to XXX for the help!

## Introduction and why

I love automation. I mean, who doesn't--You set everything up and either click away once in a while or have something automatically produced. I've decided to try and give GitHub actions a try by automating something. Similar to previous blog posts where I find an example to learn something, this post will focus making a continuously updating plot on every push. The plot will contain the packages I use for #TidyTuesday and their frequency.

In short, #Tidytuesday is an awesome weekly data project enabling you to analyze and visualize new data every week. You can find more info on the project's Github page, or read more how it helped me in my journey of learning R. Unfortunately, I haven't been participating that often lately due to thesis writing, but everyone is welcome anytime. 

The project provides a perfect opportunity for me to try a GitHub action, since every week I open a new R code for that particular dataset. This results in multiple R files containing the analysis, and more relevant to us, the packages we used. What I hope to do in this blog post is to walk you through on how to extract the packages I've used in all my TidyTuesday participation, and finally the setup I did for the Github action. I will not, however, elaborate too much on the GitHub action as I myself am a complete novice when it comes to setting up.

## Quick base R (From Michael Dorman)

Before I begin, a shout out to [Michael Dorman](https://geobgu.xyz/). A while back he posted in the Israeli R group his code for extracting the packages he uses and created a plot out of it. Essentially, that's the answer and insipiration for this post. I did however want to challenge myself in addition to the Github Action so I'll provide his code below and will walk through my tidyversian approach. Here's Michael's original code in Base R:

XXXX

## Tidyversian approach

Michael's code is fantastic, but what's a blog post without some challenges and tears.


### Reading files


```{r}
library(purrr)
library(stringr)
library(dplyr)
library(tidyr)
library(here)
library(ggplot2)
library(forcats)
library(extrafont)
```

```{r}
# Ideally, use the here package and not complete paths
tt_path <- "C:/Users/amitl/R_code/tidytuesday"
files <- list.files(path = "C:/Users/amitl/R_code/tidytuesday", pattern = "\\.R$|.Rmd$", recursive = TRUE)
files <- files[-length(files)]
```

First and most important, I recommend using the [{here}](https://github.com/jennybc/here_here) package by [Jennifer Bryan](https://jennybryan.org/). The only reason I'm using a direct path is because my R project and here assumes I'm within my website directory, making it a challenge to move between project roots. The argument basically lists all the file within the path we wrote ending in `.R` or `.Rmd`. The `recursive = TRUE` runs the same code through all subfolders. Lastly, the reason I filter the last element of the vector is because that's the code file I use to produce the plot.

```{r}
head(files)
```

We see the R scripts I used to produce my Tidytuesdays. Unfortunately, it also returns R scripts I opened but didn't completely follow through wtih the analysis. That is, sometimes I worked on a TidyTuesday but stopped and left it incomplete so it'll return that too. It's not that many and I imagine you can workaround it if you want. 

Before we dig in I want to get the name of the scripts. This is mandatory for the analysis, but I found in nicer to look at the packages used corresponding to the Tidytuesday. Of course getting the names can provide an opportunity for further analysis by Tidytuesday if you wish to do so:

```{r}
# Get names
file_names <- str_extract(files, '[^/]+(?=\\.)')

head(file_names)
```

Let's see what we did here, and to better understand the regex let's see how our original string looked like: `r files[1]`. Basically, we want to take everything after the last `/` ("National Parks.R") using `[^/]+`, and then remove everything from the final period to the end with a positive look ahead `(?=\\.)`. Voilla, our final output of "`r file_names[1]`".   

Finally we can read in the text from all these R scripts:

```{r}
tt_path <- paste0(tt_path, "\\/" ,files)
file_lines <- map(tt_path, readLines)

head(file_lines[[1]])
```

I'm definitely not your go-to when it comes to iteration such as `purrr::map`, but let me try and simplify what we just did. I first created the complete path of our scripts and then iterated the function `readLines` across it. I could have done the pasting within `map` but I wanted to simplify it for us. Essentially, you can read `map` as follows: Run function `readLines` on every element of vector `tt_path` (The vector containing our path to each R/Rmd script). For a better understanding of the `map` function I highly recommend exploring the [documentations](https://purrr.tidyverse.org/reference/map.html).

I then printed the head script so that we can look at it as we continue our extraction of packages. First off, notice I subset it using `[[1]]`, that's because `map` returned a list class. Second, and more important for our analysis, our line breaks from the original code are preserved. That means that every element of a package script (a list within a list) is essentially a line. Therefore, we can operate on it without any special regex other than searching for the `library` function.

However, a caveat is important to state: I do not attempt to capture packages called inline such as the `readr::read_csv`. It's definitely possible, but I decided not to for this example. I imagine you can easily incorporate it in some manner if you wish to do so.


### Cleaning

Ok then, now that we read all lines in let's extract all libraries. If my memory is correct, I mainly use functions either by loadings the library through `library()` or inline with `library::` so let's capture that and return a dataframe:

```{r}
names(file_lines) <- file_names
file_packages <- map_dfr(file_lines, ~ tibble(package = str_extract(.x, "((?<=library\\().+(?=\\))|[a-z].+(?=::))")),.id = "tidytuesday") %>% 
  filter(!is.na(package))

file_packages
```

Perfect! First I added the original script names as the id for each sub list within the `file_lines`. We then want to capture any library we use across all sub-lists and return it nicely in a data frame. Let's tackle each element at a time starting with the regular expression.

We can split the regex into two parts. the first one `(?<=library\\()).+(?=\\())` can be read as follows: Look for everything that comes after `library(` and before `)`. the `(?<=` is a positive look behind, basically capture everything that comes after `library\\(`. We use the two slashes to escape `(` and tell R we're specifically looking for a parenthesis. A positive look ahead and look behind should be enclosed within `()`. We want to save everything after the `library(`, and that's what `.+` does-- Capture at least one symbol and more after the look behind we wrote. The `(?=\\))` is a positive look ahead and tells our regex to expect it and read until there but exclude it.

The second section of the regex `[a-z].+(?=::))` essentially mimics the previous one but only with a positive look ahead. Capture everything before the two `::`. FINISH ADDING THE REGEX.

What we did in this argument was iterate the `str_extract` argument across each sublist of our `file_lines` object, the object that contained all our R scripts. To do this we used `map_dfr` which works similarly to `map` only returns a `data.frame` and not a list. Here I specifically returned a `tibble`, but either one works. Since it returns a data frame we can provide a column name, here it's assigned as `package`. In addition, `map_df*` (map_df, map_dfr, etc.) can take an `.id` argument the will return the names of the original sub-lists as a column. Lastly all lines that didn't match our regex - empty lines, arguments, comments, etc. - returned `NA` (actually that's the majority of lines) so we filtered them.

### plot

We're at the last part of reading-processing-plotting journey. The plot is pretty straight forward and I invite you to explore other plots. However, remember that we're gonna want it to be automated so make sure you don't create something you'll have to return to it. For example, if you wish to add each time a new name for that week you'll have to provide room for it in future rendering. 

```{r fig.cap='the plot we want to be rendered everytime we push to our Tidytuesday repository'}

file_packages %>% 
  count(package, sort = T) %>%
  slice(1:15) %>% 
  ggplot()+
  geom_col(aes(y= fct_reorder(package,n), x = n))+
  labs(title = "Top 15 frequently used packages in #Tidytuesday",
       subtitle = "Plot is automated on every GitHub push to our #TidyTuesday repository",
       x = "Number of times used", y = "Package name",
       caption = paste0("Last updated:\n",format(Sys.Date(), "%b %d, %Y")))+
  theme_minimal()+
  theme(
    text = element_text(family = "Roboto Condensed"),
    plot.title = element_text(size = 16),
    plot.title.position = "plot",
    plot.subtitle = element_text(size = 12, color = "gray20"),
    plot.caption = element_text(color = "gray30", face = "italic"),
    axis.title = element_text(color = "gray30"),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 11),
    plot.margin = unit(c(4,2,2,4), "mm")
  )

# Save somewhere.
# ggsave ("packages.png")
```

Above we created the plot we're gonna want to be rendered every time we push. A few things to note:  

1. I created a simple bar chart but feel free to explore other plots. Also, if you don't intend of having it rendered every time you push to GitHub then go crazy with other plots. I wanted to keep it simple but I'm sure you can explore other plots.  

2. I decided to only take the top 15 frequently used packages. You can play around with it to find a number you like or one that properly fits.

3. Notice that I added to the caption the date it was rendered. This will update every time our plot updates, i.e. every time we push to our #TidyTuesday repository.

Looking at the plot I notice I load various packages twice 😅, mostly if I load the `{tidyverse}` and then again in specifically such as `stringr` or `lubridate`. At least now I'll remember this for future work!


## GitHub action

Well this was my first time around using GitHub action. Unfortunately, I don't know much about GitHub actions so I'll first suggest a few resources I found useful:

1. Jim Hester's [rstudio talk](https://www.jimhester.com/talk/2020-rsc-github-actions/) on GitHub actions - Great resource for an introduction and to get you excited about the opportunities with GitHub action. 

2. Gavin Simpson's blog post ['Rendering your README with GitHub Actions
'](https://fromthebottomoftheheap.net/2020/04/30/rendering-your-readme-with-github-actions/) - A more hands-on approach on setting everything up. I mainly followed along his blog post which I highly recommend you do too.

Seriously, I highly recommend following Gavin Simpson's approach. In any event, here are the steps I did:

1. If you don't have the `{usethis}` package, make sure to install it with `install.packages("usethis")`. The package makes it extremely easy to work with GitHub Actions with providing great templates and setups.

2. Next we're going to create a `.yaml` file that will contain all our commands. the `usethise` package provides many templates for bookdowns, blogdowns, packages, etc. I found the `README.Rmd` template suitable to learn from so we'll create that. Just type the following in the r console in the root folder of your repository:  


```
usethis::use_github_action()
```

And you should get the following output, only with your folders instead:

```
√ Setting active project to 'C:/Users/amitl/R_code/TidyTuesday'
√ Creating '.github/'
√ Adding '^\\.github$' to '.Rbuildignore'
√ Adding '*.html' to '.github/.gitignore'
√ Creating '.github/workflows/'
√ Writing '.github/workflows/R-CMD-check.yaml'
* Copy and paste the following lines into 'C:/Users/amitl/R_code/TidyTuesday/README.md':
  <!-- badges: start -->
  [![R build status](https://github.com/AmitLevinson/TidyTuesday/workflows/R-CMD-check/badge.svg)](https://github.com/AmitLevinson/TidyTuesday/actions)
  <!-- badges: end -->
```

Perfect. We're not going to copy the lines suggested as they're helpful for package checks, and we're only interested in producing a plot.

```
> usethis::use_github_actions()
√ Setting active project to 'C:/Users/amitl/R_code/TidyTuesday'
√ Creating '.github/'
√ Adding '^\\.github$' to '.Rbuildignore'
√ Adding '*.html' to '.github/.gitignore'
√ Creating '.github/workflows/'
√ Writing '.github/workflows/R-CMD-check.yaml'
* Copy and paste the following lines into 'C:/Users/amitl/R_code/TidyTuesday/README.md':
  <!-- badges: start -->
  [![R build status](https://github.com/AmitLevinson/TidyTuesday/workflows/R-CMD-check/badge.svg)](https://github.com/AmitLevinson/TidyTuesday/actions)
  <!-- badges: end -->
```

