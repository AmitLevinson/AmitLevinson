---
title: Translating Regex to SQL String Operations
author: Amit Levinson
date: '2022-06-02'
slug: regex-in-sql
categories: []
tags: [R, Python, SQL]
subtitle: 'Learning how to do several string operations with SQL'
summary: 'Unfortunately, a lot of Regex operations are not available in (MS)SQL. In this post I show how I take several regex operations I like and convert thme to string manipulations with SQL syntax'
featured: yes
image:
  caption: ''
  focal_point: ''
  preview_only: yes
projects: []
draft: false
codefolding_show: show
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, eval = TRUE)
```

```{r, echo = FALSE}
knit_print.data.frame = function(x, ...) {
  res = paste(c("", "", knitr::kable(x)), collapse = "\n")
  knitr::asis_output(res)
}

registerS3method(
  "knit_print", "data.frame", knit_print.data.frame,
  envir = asNamespace("knitr")
)
```


Working as a Data Analyst in the fraud domain I constantly find myself manipulating text using regex and simple text operations.

Regex is 'a sequence of characters that specifies a search pattern in text' (~[Wikipedia](https://en.wikipedia.org/wiki/Regular_expression)). Basically,  we provide a set of rules and guidelines to identify - and accordingly extract, remove, replace, etc - a pattern in the text.

Appreciating the power of Regex and simple text operations in R & Python I use, doing them in SQL - at lease in MSSQL we currently use - requires adaptations. 

In this post We'll go over three scenarios I faced in the past both in some coding language and while using SQL. As I've recently picked up Python more I'll also solve some of them using that, **but the general idea is pretty language agnostic, using regex and working with text.**

What will we be be looking at?

1. [Using looksarounds to extract the email domain](#lookarounds)  

1. [Joining tables on a partial string match](#partial-strings)  

1. [Separating text & digits to different columns](#separate)


### Setup

Let's start by setting up a local connection so we can easily write SQL queries as we move forward:

```{r echo = FALSE}
library(odbc)
library(DBI)

rconn <- dbConnect(odbc(),
                      Driver = "SQL Server",
                      Server = "localhost\\SQLEXPRESS",
                      Database = "regex")
```


```{r echo = FALSE}
# Partial strings
partial_identifiers <- data.frame(
    id = c("b510-442c-b0d1", "fc8f-4234-b77f", "6df08994-0335-4463-a921")
)
# payments <- read.csv('content/post/regex-in-sql/data.csv')
# dbWriteTable(rconn, 'Partial_identifiers', partial_identifiers)
# dbWriteTable(rconn, 'Payments', payments, overwrite = TRUE)
```

Awesome. As we move forward we'll be working with both Python (mainly) a little R too. So let's load the relevant libraries and data so we have them for future manipulations.


```{python}
# Python code
import pandas as pd

# content/post/regex-in-sql/
payments = pd.read_csv('data.csv')
```



```{r}
#R code
library(tidyverse)
# content/post/regex-in-sql/
payments <- read_csv('data.csv')
```

##### The Data

Our main dataset is a very simple payments table:

```{r}
payments
```
The data has 6 rows in total detailing payments: The receiver's email, the payment identifier (e.g. id) and the payment description. Feel free to follow along; you can find the relevant dataset in the [website's GitHub repository]().

All right then, let's (^begin|start$)

### Lookarounds ðŸ‘€ â€” Extracting the domain from an email address {#lookarounds}

[lookarounds](https://www.regular-expressions.info/lookaround.html) are definitely one of my favorite and commonly go-to regex operations. As the name implies, **a lookaround searches for a pattern and specified string in a specific piece of text.** A *lookahead* searches for the pattern and takes what's before it, while a *lookbehind* searches for the pattern and takes what follows it. They both can be positive or negative, while the former searches for a match (positive match) and the latter searches for the string without a match to the pattern/symbol referenced.

Let's try this with a set of emails. **For example you might want to extract the email domains, which is everything that's after the @ symbol.**

##### Python

Returning to our table, we can do this using the following regex operation:

```{python}
(
payments
  .loc[:, ['email']]
  .assign (
    email_domain = payments.email.str.extract(r'((?<=@).+)') # <- relevant part
  )
)
```


the pattern `(?<=@).+` essentially extracts any character(s) that follow the @ symbol, in this case our email domain[^1]. Alternatively if we were interested in extracting email users instead we could use a positive lookahead, looking for the '@' symbol only this time taking what's before it (e.g. r'(.+(?=@))'). If you're interested learning more about lookarounds, check out another post of mine where I extracted [libraries I used in #TidyTuesday](https://amitlevinson.com/blog/automated-plot-with-github-actions/)

[^1]: The extra parentheses is to solve the 'ValueError: pattern contains no capture groups' error, basically including what is it we want to be captured in our regex.

##### SQL

So how can we do some variation of a lookaround in SQL? 

Well, I mainly use it for the positive lookahead/behind, where we can identify the character's location and extract anything after it:

```{sql connection=rconn, echo = TRUE}
SELECT DISTINCT email,
  RIGHT(EMAIL, LEN(EMAIL) - CHARINDEX('@',EMAIL)) AS email_domain
FROM PAYMENTS p
```


We're leveraging the function `CHARINDEX` in order to identify the location of the '@' symbol, and then extract all text from that location forward.

### Partial string join â€” identifying a string from a partial match {#partial-strings}

I wouldn't say this is a common thing I do, but I had to do it once and was pretty pleased with the solution. Assuming you have another column/dataset with partial matching strings to your primary key, how can you join the two tables?

For example, you received from some partner a list of ids he has for each payment. However, what he has is only a part of the full string, as we can see below:

```{r}
partial_identifiers
```
these strings are contained in our payments table column 'payment_identifier', but how can we easily join them considering it's not an exact match?

##### R

At the time I encountered this I was using mainly R and solved it with that, so let's go ahead and use that first:

```{r echo = FALSE}
# 
# check_payment_id_exists <- function (payment_id) {
#   result = partial_identifiers$id[map_lgl(partial_identifiers$id, ~ str_detect(payment_id, .))]
#   result = ifelse(is_empty(result), NA, result)
#   return(result)
# }
# 
# payments %>% 
#   mutate(
#     identifier = map_chr(payment_identifier, check_payment_id_exists),
#     .before = 'payment_identifier', .keep='used'
#   )


# So what do we have here? Well the idea is to iterate across all payment identifiers we have and see which of the partial identifiers matches it. To do this we break the process up, the first section is a function to do exactly that, identify if a payment matches any of the partial identifiers, and the second section is the analysis in which I iterate across all payment identifiers and check if they match. 


```


```{r}
library(fuzzyjoin)

regex_left_join(x = payments, y = partial_identifiers,
                by = c('payment_identifier' = 'id')) %>% 
  select(payment_identifier, id)
```


I initially had a different answer that basically extracted which values matched as a new column, and then joined on that; But I really like this solution above instead as it shows the awesome power of the [{fuzzyjoin}](https://cran.r-project.org/web/packages/fuzzyjoin/index.html) R package. 

I realized this post solves the other two challenges with Python, so I might as well try it with that too. You know, just for the kicks:

```{python}
partial_identifiers = r.partial_identifiers
```


```{python}
# payments['join'] = 1
# partial_identifiers['join'] = 1
# 
# payments_joined = payments.merge(partial_identifiers, on = 'join').drop('join', axis = 1)
# payments_joined['match'] payments_joined.apply(lambda x: x.payment_identifier.find(x.id), axis = 1).ge(0)
# payments_joined.head()
```
Now let's turn to SQL and solve it there.

##### SQL

```{sql connection=rconn, echo = TRUE}
SELECT TOP 6 payment_identifier,
  pi.id
FROM PAYMENTS p
LEFT JOIN partial_identifiers pi
  on p.payment_identifier like concat('%', pi.id, '%')
```



The idea is pretty straight forward. We can leverage the `LIKE` operator in a join to do the partial matching for us, matching any payment identifiers to the partial identifiers id.

Interestingly, at the time of facing this challenge at work I started it with R. However, this requried downloading many of the payments and wasn't easily scalable. Eventually I realized this and just implemented it using SQL as shown above.

### Extracting / Separating text & digits. {#separate}

Occasionally you might encounter values that contain both a string and digits combined, for example payment descriptions, email users, security answers and more. Being able to separate the text from numbers might be a necessary step for cleaning our data and further analysis. Let's see how can we do this on the column payment_description that contains both what seems as a name and digits.

#### Python

```{python echo=TRUE}
payments[['name', 'number']] = (
  payments.payment_description.str.split(r'(\d+)', expand = True)
  .iloc[:, 0:2]
)

payments[['payment_description', 'name', 'number']]
```


it's pretty straightforward using the python `split` argument. We pass it a pattern to separate by and wrap it in a parenetheses (so it won't drop). From there we just remove an empty column and assign it as new columns in our dataframe.

I don't show it here but in R we could easily use the `tidyr::separate` that does exactly that -- Separates a string into new columns.

#### SQL

This requires a little more work, as we want to split it while we have varying lengths of numbers across strings. For this we can use Translate and convert any characters or digits - according to what we're extracting - to a blank value.

```{sql connection=rconn}
SELECT TOP 6
  Payment_Description,
  REPLACE(TRANSLATE(PAYMENT_DESCRIPTION, '0123456789',
                                         '##########'),
          '#','') AS Name,
  REPLACE(TRANSLATE(PAYMENT_DESCRIPTION, 'abcdefghijklmnopqrstuvwxyz.',
                                         '###########################'),
          '#','') AS Numbers
FROM PAYMENTS
```
We combine the `TRANSLATE` and `REPALCE` functions to do a string-extract kind of operation. The Translate basically converts any of the characters noted in the second argument to a character in the third argument. We then replace all hashtags to empty values.

This is done both for the name and numbers, converting all letters and a period to empty values, and all numbers to empty values correspondingly.

You usually would have data that's a little messier, e.g. numbers appearing in between letters, but it should give the main idea and help you start from there (or at least did so for me).

### Conclusion

In this blog post we solved three cases using some regex and text manipulations. Sometimes I found myself doing it on ther server's side with SQL, others locally with R or Python. **I think it's mainly knowing that it can be done that gets you most of the way there. The how is just a matter of Googling.**



```{r, echo = FALSE}
# library(readr)
# dat <- read_csv('content/post/regex-in-sql/data.csv')

# dbWriteTable(conn = rconn,
#             'Payments',
#             dat,
#             overwrite = TRUE)
```


```{r echo = FALSE}
dbDisconnect(rconn)
```

